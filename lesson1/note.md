# javascript 执行机制

分为编译阶段和执行阶段

## \* 编译阶段

#### 词法分析

JS 引擎会将我们写的代码当成字符串分解成词法单元。例如，var a = 2，这段程序会被分解成：“var、a、=、2、；”

五个 token。每个词法单元 token 不可再分割

#### 语法分析

将词法单元转化成树状结构的抽象语法树（AST）

#### 生成代码

将 AST 转换为可执行代码的过程称为代码生成，因为计算机只能识别机器指令，需要通过某种方法将
var a = 2; 的 AST 转化为一组机器指令，用来创建 a
的变量（包括分配内存），并将值存储在 a 中

## \* 执行阶段

#### 执行上下文

全局执行上下文—— 当 JS 引擎执行全局代码的时候，会编译全局代码并创建执行上下文，它会做两件事：

    1、创建一个全局的 window 对象(浏览器环境下)

    2、将 this 的值设置为该全局对象；全局上下文在整个页面生命周期有效，并且只有一份

函数执行上下文——当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，
创建的函数执行上下文会被销毁。

#### 执行栈

执行栈，在其它编程语言中被叫做“调用栈”，是一种 LIFO（后进先出）栈的数据结构，被用来存储代码运行时创建的所有执行上下文。

#### 创建执行上下文

注：函数在调用的时候才会创建执上下文

绑定 this————全局上下文指向 windows

创建词法环境————环境记录,记录标识符和变量之间的关联，外部环境引入（作用域链）

创建变量环境————也是一种词法环境，ES6 词法环境和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定，这也是为什么 var 声明的变量存在变量提升

#### 执行阶段

执行 JavaScript 代码了。在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined
